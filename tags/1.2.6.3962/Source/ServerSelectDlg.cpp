// This file was generated by WTL Dialog wizard 
// ServerSelectDlg.cpp : Implementation of CServerSelectDlg

#include "stdafx.h"
#include "ServerSelectDlg.h"

// CServerSelectDlg
CServerSelectDlg::CServerSelectDlg()
{
}

CServerSelectDlg::~CServerSelectDlg()
{
}

LRESULT CServerSelectDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_done = false;
//	DlgResize_Init();
	//SetWindowLong(GWL_EXSTYLE, GetWindowLong(GWL_EXSTYLE)| WS_EX_PALETTEWINDOW);
	return 1;  // Let the system set the focus
}

LRESULT CServerSelectDlg::OnClickedOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
//	EndDialog(wID);
	return 0;
}

LRESULT CServerSelectDlg::OnClickedCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	//EndDialog(wID);
	return 0;
}




LRESULT CServerSelectDlg::OnShowWindow(BOOL fShow, UINT status)
{


	
	return 0;
}

#include <multimon.h>
bool CServerSelectDlg::ShowPopup(HWND hwndOwner)
{
	/*if(!m_hWnd)
	Create(HWND_DESKTOP, 0);*/


	//CListViewCtrl crl;
	if(!m_hWnd)
	Create(hwndOwner, CRect(0,0,400,400),0,WS_POPUP,WS_EX_TOOLWINDOW | LVS_REPORT |    /* So it doesn't show up in taskbar */                 
                WS_EX_DLGMODALFRAME |  /* Get the edges right */                 
                WS_EX_WINDOWEDGE |
                WS_EX_TOPMOST);
	AddColumn(_T("Название сервера"),0);
		AddColumn(_T("Авторизация"),1);
		AddItem(0,0,_T("VKONTAKTE"));
	HWND hwndActive;
	HWND hwndPopup = m_hWnd; //m_hWnd;
		::ShowWindow(hwndPopup, SW_SHOWNOACTIVATE);
	  m_done = false;
    /*
    *  We want to receive all mouse messages, but since
    *  only the active window can capture the mouse,
    *  we have to set the capture to our owner window,
    *  and then steal the mouse messages out from under him.
    */
CMessageLoop* pLoop = _Module.GetMessageLoop();
	ATLASSERT(pLoop != NULL);
	pLoop->AddMessageFilter(this);
  ::SetCapture(hwndOwner);
	  return 0;
	
 
    /*
    *  Go into a message loop that filters all the messages
    *  it receives and routes the interesting ones to the
    *  color picker window.
    */
	MSG msg;
	POINT pt;
	POINT pt2;
	HWND h;
    while (GetMessage(&msg, NULL, 0, 0)) {
 
        /*
        *  Something may have happened that caused us to stop.
        *  If so, then stop.
        */
        //if (cps.fDone) break;
 
        /*
        *  If our owner stopped being the active window
        *  (e.g., the user Alt+Tab'd to another window
        *  in the meantime), then stop.
        */
       hwndActive = GetActiveWindow();
        if (hwndActive != hwndOwner &&
			  !::IsChild(hwndActive, hwndOwner)) break;
        if (GetCapture() != hwndOwner) break;
 
        /*
        *  At this point, we get to snoop at all input messages         
        *  before they get dispatched.  This allows us to
        *  route all input to our popup window even if really
        *  belongs to somebody else.
        *
        *  All mouse messages are remunged and directed at our
        *  popup menu.  If the mouse message arrives as client
        *  coordinates, then we have to convert it from the
        *  client coordinates of the original target to the
        *  client coordinates of the new target.
        */
 
        switch (msg.message) {
 
        /*
        *  These mouse messages arrive in client coordinates,
        *  so in addition to stealing the message, we also
        *  need to convert the coordinates.
        */
        
        case WM_LBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_RBUTTONDBLCLK:
        case WM_MBUTTONDOWN:
        case WM_MBUTTONUP:
        case WM_MBUTTONDBLCLK:
			pt.x = (short)LOWORD(msg.lParam);
            pt.y = (short)HIWORD(msg.lParam);
				pt2=pt;
				::ClientToScreen(msg.hwnd, &pt2);
				if(WindowFromPoint(pt2)!=m_hWnd)
				{
					m_done = true;
				}
				::MapWindowPoints(msg.hwnd, hwndPopup, &pt, 1);
            msg.lParam = MAKELPARAM(pt.x, pt.y);
            msg.hwnd = hwndPopup;
            break;

			  case WM_MOUSEMOVE:
            pt.x = (short)LOWORD(msg.lParam);
            pt.y = (short)HIWORD(msg.lParam);
				::MapWindowPoints(msg.hwnd, hwndPopup, &pt, 1);
            msg.lParam = MAKELPARAM(pt.x, pt.y);
            msg.hwnd = hwndPopup;
            break;
 
        /*
        *  These mouse messages arrive in screen coordinates,
        *  so we just need to steal the message.
        */
        case WM_NCMOUSEMOVE:
        case WM_NCLBUTTONDOWN:
        case WM_NCLBUTTONUP:
        case WM_NCLBUTTONDBLCLK:
        case WM_NCRBUTTONDOWN:
        case WM_NCRBUTTONUP:
        case WM_NCRBUTTONDBLCLK:
        case WM_NCMBUTTONDOWN:
        case WM_NCMBUTTONUP:
        case WM_NCMBUTTONDBLCLK:
            msg.hwnd = hwndPopup;
            break;
 
        /*
        *  Steal all keyboard messages, too.
        */
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSKEYDOWN:
        case WM_SYSKEYUP:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
            msg.hwnd = hwndPopup;
            break;
 
        }
 
		 
 
        /*
        *  Something may have happened that caused us to stop.
        *  If so, then stop.
        */
        if (m_done) break;
 
        /*
        *  If our owner stopped being the active window
        *  (e.g., the user Alt+Tab'd to another window
        *  in the meantime), then stop.
        */
        hwndActive = GetActiveWindow();
        if (hwndActive != hwndOwner &&
			  !::IsChild(hwndActive, hwndOwner)) break;
        if (GetCapture() != hwndOwner) break;
 
    }
	 ::ReleaseCapture();
	 ShowWindow(SW_HIDE);
	 // DestroyWindow(hwndPopup);
 
    /*
    *  If we got a WM_QUIT message, then re-post it so the caller's     
    *  message loop will see it.q
    */
    if (msg.message == WM_QUIT) {
        PostQuitMessage(msg.wParam);
    }

	 return true;

}

LRESULT CServerSelectDlg::OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	bHandled=true; return MA_NOACTIVATE;
}
LRESULT CServerSelectDlg::OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	bHandled=true; return /*MA_NOACTIVATE*/0;
}


BOOL CServerSelectDlg::PreTranslateMessage(MSG* pMsg)
{
	MSG msg = *pMsg;POINT pt;
	HWND hwndActive;
	HWND hwndOwner = GetParent();
	HWND hwndPopup = m_hWnd;

	POINT pt2;
	HWND h;
	switch (msg.message) {
 
        /*
        *  These mouse messages arrive in client coordinates,
        *  so in addition to stealing the message, we also
        *  need to convert the coordinates.
        */
        
        case WM_LBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_RBUTTONDBLCLK:
        case WM_MBUTTONDOWN:
        case WM_MBUTTONUP:
        case WM_MBUTTONDBLCLK:
			pt.x = (short)LOWORD(msg.lParam);
            pt.y = (short)HIWORD(msg.lParam);
				pt2=pt;
				::ClientToScreen(msg.hwnd, &pt2);
				if(WindowFromPoint(pt2)!=m_hWnd)
				{
					m_done = true;
				}
				::MapWindowPoints(msg.hwnd, hwndPopup, &pt, 1);
            msg.lParam = MAKELPARAM(pt.x, pt.y);
            msg.hwnd = hwndPopup;
            break;

			  case WM_MOUSEMOVE:
            pt.x = (short)LOWORD(msg.lParam);
            pt.y = (short)HIWORD(msg.lParam);
				::MapWindowPoints(msg.hwnd, hwndPopup, &pt, 1);
            msg.lParam = MAKELPARAM(pt.x, pt.y);
            msg.hwnd = hwndPopup;
            break;
 
        /*
        *  These mouse messages arrive in screen coordinates,
        *  so we just need to steal the message.
        */
        case WM_NCMOUSEMOVE:
        case WM_NCLBUTTONDOWN:
        case WM_NCLBUTTONUP:
        case WM_NCLBUTTONDBLCLK:
        case WM_NCRBUTTONDOWN:
        case WM_NCRBUTTONUP:
        case WM_NCRBUTTONDBLCLK:
        case WM_NCMBUTTONDOWN:
        case WM_NCMBUTTONUP:
        case WM_NCMBUTTONDBLCLK:
            msg.hwnd = hwndPopup;
            break;
 
        /*
        *  Steal all keyboard messages, too.
        */
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSKEYDOWN:
        case WM_SYSKEYUP:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
            msg.hwnd = hwndPopup;
            break;
 
        }

	*pMsg = msg;
	if(m_done){
	::ReleaseCapture();
	 ShowWindow(SW_HIDE);
	 	CMessageLoop* pLoop = _Module.GetMessageLoop();
	ATLASSERT(pLoop != NULL);
	pLoop->RemoveMessageFilter(this);
	m_done = false;
	}
	return false;
}